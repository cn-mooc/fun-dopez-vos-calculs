--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         49152 B, 64 B, 12-way associative
LL cache:         25165824 B, 64 B, 12-way associative
Command:          ./a.out
Data file:        cachegrind.out.16621
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                     I1mr           ILmr           Dr                   D1mr                 DLmr                 Dw                   D1mw                DLmw                
--------------------------------------------------------------------------------
5,203,725,154 (100.0%) 2,253 (100.0%) 2,164 (100.0%) 600,779,910 (100.0%) 450,017,995 (100.0%) 100,027,338 (100.0%) 200,281,470 (100.0%) 50,002,547 (100.0%) 50,001,805 (100.0%)  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                     I1mr         ILmr         Dr                   D1mr                 DLmr                Dw                   D1mw                DLmw                 file:function
--------------------------------------------------------------------------------
2,800,180,012 (53.81%)   2 ( 0.09%)   2 ( 0.09%) 400,000,001 (66.58%) 400,000,001 (88.89%) 50,018,853 (50.01%)           0                   0                   0           /var/tmp/MOOC_M4/doublement_contracte/prod_dc.cpp:v1(double const*, int, int)
1,600,300,021 (30.75%)   3 ( 0.13%)   3 ( 0.14%) 200,000,001 (33.29%)  50,000,002 (11.11%) 49,998,857 (49.99%)           0                   0                   0           /var/tmp/MOOC_M4/doublement_contracte/prod_dc.cpp:v2(double const*, int, int)
  800,000,002 (15.37%)   0            0                    0                    0                   0          200,000,000 (99.86%) 50,000,000 (99.99%) 50,000,000 (100.0%)  /usr/include/c++/11/bits/stl_algobase.h:main

--------------------------------------------------------------------------------
-- Auto-annotated source: /var/tmp/MOOC_M4/doublement_contracte/prod_dc.cpp
--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                   D1mr                 DLmr                Dw         D1mw       DLmw       

            .          .          .                    .                    .                   .          .          .          .           #include <cmath>
            .          .          .                    .                    .                   .          .          .          .           #include <iostream>
            .          .          .                    .                    .                   .          .          .          .           using namespace std;
            .          .          .                    .                    .                   .          .          .          .           
            .          .          .                    .                    .                   .          .          .          .           double v1(const double *A, int M, int K)
            .          .          .                    .                    .                   .          .          .          .           {
            3 ( 0.00%) 0          0                    0                    0                   0          0          0          0              double r = 0.;
       80,005 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)           0                    0                   0          0          0          0              for (int i = 0; i < M; ++i)
            .          .          .                    .                    .                   .          .          .          .              {
1,600,100,000 (30.75%) 0          0                    0                    0                   0          0          0          0                 for (int j = 0; j < K; ++j)
            .          .          .                    .                    .                   .          .          .          .                 {
1,200,000,000 (23.06%) 1 ( 0.04%) 1 ( 0.05%) 400,000,000 (66.58%) 400,000,000 (88.89%) 50,018,852 (50.01%) 0          0          0                    r += pow(A[j * M + i], 2.);
            .          .          .                    .                    .                   .          .          .          .                 }
            .          .          .                    .                    .                   .          .          .          .              }
            3 ( 0.00%) 0          0                    0                    0                   0          0          0          0              return sqrt(r);
            1 ( 0.00%) 0          0                    1 ( 0.00%)           1 ( 0.00%)          1 ( 0.00%) 0          0          0           }
            .          .          .                    .                    .                   .          .          .          .           double v2(const double *A, int M, int K)
            3 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)           0                    0                   0          0          0          0           {
            2 ( 0.00%) 0          0                    0                    0                   0          0          0          0              double r = 0.;
       80,012 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)           0                    0                   0          0          0          0              for (int j = 0; j < K; ++j)
            .          .          .                    .                    .                   .          .          .          .              {
  400,220,000 ( 7.69%) 1 ( 0.04%) 1 ( 0.05%)           0                    0                   0          0          0          0                 for (int i = 0; i < M; ++i)
            .          .          .                    .                    .                   .          .          .          .                 {
1,200,000,000 (23.06%) 0          0          200,000,000 (33.29%)  50,000,001 (11.11%) 49,998,856 (49.99%) 0          0          0                    r += pow(A[j * M + i], 2.);
            .          .          .                    .                    .                   .          .          .          .                 }
            .          .          .                    .                    .                   .          .          .          .              }
            3 ( 0.00%) 0          0                    0                    0                   0          0          0          0              return sqrt(r);
            1 ( 0.00%) 0          0                    1 ( 0.00%)           1 ( 0.00%)          1 ( 0.00%) 0          0          0           }
            .          .          .                    .                    .                   .          .          .          .           int main()
            3 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)           0                    0                   0          3 ( 0.00%) 0          0           {
            .          .          .                    .                    .                   .          .          .          .              int m = 20000;
            8 ( 0.00%) 0          0                    0                    0                   0          2 ( 0.00%) 0          0              cout << "Allocation matrice A " << m << "x" << m << endl;
            5 ( 0.00%) 0          0                    1 ( 0.00%)           0                   0          1 ( 0.00%) 0          0              double *A = new double[m * m];
            .          .          .                    .                    .                   .          .          .          .           
            .          .          .                    .                    .                   .          .          .          .              fill(A, A + m * m, 1.);
            .          .          .                    .                    .                   .          .          .          .              clock_t ta;
            2 ( 0.00%) 1 ( 0.04%) 1 ( 0.05%)           0                    0                   0          1 ( 0.00%) 1 ( 0.00%) 1 ( 0.00%)     ta = clock();
            4 ( 0.00%) 0          0                    0                    0                   0          1 ( 0.00%) 0          0              cout << "v1 " << v1(A, m, m);
            3 ( 0.00%) 0          0                    0                    0                   0          1 ( 0.00%) 0          0              ta = clock() - ta;
            3 ( 0.00%) 0          0                    1 ( 0.00%)           1 ( 0.00%)          1 ( 0.00%) 0          0          0              cout << " " << (ta * 1.) / CLOCKS_PER_SEC << endl;
            2 ( 0.00%) 0          0                    0                    0                   0          1 ( 0.00%) 0          0              ta = clock();
            4 ( 0.00%) 0          0                    0                    0                   0          1 ( 0.00%) 0          0              cout << "v2 " << v2(A, m, m);
            3 ( 0.00%) 0          0                    0                    0                   0          1 ( 0.00%) 0          0              ta = clock() - ta;
            3 ( 0.00%) 0          0                    1 ( 0.00%)           1 ( 0.00%)          1 ( 0.00%) 0          0          0              cout << " " << (ta * 1.) / CLOCKS_PER_SEC << endl;
            7 ( 0.00%) 0          0                    4 ( 0.00%)           1 ( 0.00%)          1 ( 0.00%) 0          0          0           }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/11/bits/stl_algobase.h
--------------------------------------------------------------------------------
Ir                   I1mr       ILmr       Dr         D1mr       DLmr       Dw                   D1mw                DLmw                

-- line 915 ----------------------------------------
          .          .          .          .          .          .                    .                   .                   .             template<typename _ForwardIterator, typename _Tp>
          .          .          .          .          .          .                    .                   .                   .               _GLIBCXX20_CONSTEXPR
          .          .          .          .          .          .                    .                   .                   .               inline typename
          .          .          .          .          .          .                    .                   .                   .               __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
          .          .          .          .          .          .                    .                   .                   .               __fill_a1(_ForwardIterator __first, _ForwardIterator __last,
          .          .          .          .          .          .                    .                   .                   .           	      const _Tp& __value)
          .          .          .          .          .          .                    .                   .                   .               {
          .          .          .          .          .          .                    .                   .                   .                 const _Tp __tmp = __value;
600,000,002 (11.53%) 0          0          0          0          0                    0                   0                   0                 for (; __first != __last; ++__first)
200,000,000 ( 3.84%) 0          0          0          0          0          200,000,000 (99.86%) 50,000,000 (99.99%) 50,000,000 (100.0%)  	*__first = __tmp;
          .          .          .          .          .          .                    .                   .                   .               }
          .          .          .          .          .          .                    .                   .                   .           
          .          .          .          .          .          .                    .                   .                   .             // Specialization: for char types we can use memset.
          .          .          .          .          .          .                    .                   .                   .             template<typename _Tp>
          .          .          .          .          .          .                    .                   .                   .               _GLIBCXX20_CONSTEXPR
          .          .          .          .          .          .                    .                   .                   .               inline typename
          .          .          .          .          .          .                    .                   .                   .               __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
          .          .          .          .          .          .                    .                   .                   .               __fill_a1(_Tp* __first, _Tp* __last, const _Tp& __c)
-- line 932 ----------------------------------------

--------------------------------------------------------------------------------
Ir                     I1mr       ILmr       Dr                   D1mr                 DLmr                 Dw                   D1mw                DLmw                
--------------------------------------------------------------------------------
5,200,480,082 (99.94%) 7 ( 0.31%) 7 ( 0.32%) 600,000,009 (99.87%) 450,000,006 (100.0%) 100,017,713 (99.99%) 200,000,012 (99.86%) 50,000,001 (99.99%) 50,000,001 (100.0%)  events annotated

